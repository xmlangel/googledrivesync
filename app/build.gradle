plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.compose)
    alias(libs.plugins.ksp)
    id 'jacoco'
}

android {
    namespace 'uk.xmlangel.googledrivesync'
    compileSdk {
        version = release(36)
    }

    defaultConfig {
        applicationId "uk.xmlangel.googledrivesync"
        minSdk 24
        targetSdk 36
        versionCode 26
        versionName "1.6.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        debug {
            enableUnitTestCoverage true
        }
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_11
        targetCompatibility JavaVersion.VERSION_11
    }
    buildFeatures {
        compose true
    }
    packaging {
        resources {
            excludes += "META-INF/INDEX.LIST"
            excludes += "META-INF/DEPENDENCIES"
        }
    }

    testOptions {
        unitTests {
            includeAndroidResources = true
        }
        unitTests.all {
            testLogging {
                events "passed", "skipped", "failed", "standardOut", "standardError"
                exceptionFormat "full"
                showExceptions true
                showCauses true
                showStackTraces true
            }
        }
    }
}


dependencies {
    implementation libs.androidx.core.ktx
    implementation libs.androidx.lifecycle.runtime.ktx
    implementation libs.androidx.activity.compose
    implementation platform(libs.androidx.compose.bom)
    implementation libs.androidx.compose.ui
    implementation libs.androidx.compose.ui.graphics
    implementation libs.androidx.compose.ui.tooling.preview
    implementation libs.androidx.compose.material3
    
    // Google Drive Sync dependencies
    implementation libs.google.play.services.auth
    implementation(libs.google.api.client.android) {
        exclude group: 'org.apache.httpcomponents'
    }
    implementation(libs.google.api.services.drive) {
        exclude group: 'org.apache.httpcomponents'
        exclude module: 'guava-jdk5'
    }
    
    // Room Database
    implementation libs.androidx.room.runtime
    implementation libs.androidx.room.ktx
    ksp libs.androidx.room.compiler
    
    // WorkManager
    implementation libs.androidx.work.runtime.ktx
    
    // Navigation Compose
    implementation libs.androidx.navigation.compose
    
    // Security (EncryptedSharedPreferences)
    implementation libs.androidx.security.crypto
    
    // ViewModel Compose
    implementation libs.androidx.lifecycle.viewmodel.compose
    
    // Coroutines
    implementation libs.kotlinx.coroutines.android
    implementation libs.kotlinx.coroutines.core
    
    // Coil for image loading
    implementation libs.coil.compose
    
    // Material Icons Extended
    implementation libs.androidx.material.icons.extended
    
    testImplementation libs.junit
    testImplementation libs.mockk
    testImplementation libs.kotlinx.coroutines.test
    testImplementation libs.turbine
    testImplementation libs.robolectric
    testImplementation libs.androidx.test.core
    testImplementation libs.androidx.work.testing
    testImplementation libs.androidx.compose.ui.test.junit4
    debugImplementation libs.androidx.compose.ui.test.manifest
    androidTestImplementation libs.androidx.junit
    androidTestImplementation libs.androidx.espresso.core
    androidTestImplementation platform(libs.androidx.compose.bom)
    androidTestImplementation libs.androidx.compose.ui.test.junit4
    debugImplementation libs.androidx.compose.ui.tooling
    debugImplementation libs.androidx.compose.ui.test.manifest
}
jacoco {
    toolVersion = libs.versions.jacoco.get()
}

tasks.withType(Test).configureEach {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

project.afterEvaluate {
    tasks.register('jacocoTestReport', JacocoReport) {
        dependsOn 'testDebugUnitTest'

        reports {
            xml.required = true
            html.required = true
        }

        def fileFilter = [
            '**/R.class',
            '**/R$*.class',
            '**/BuildConfig.*',
            '**/Manifest*.*',
            '**/*Test*.*',
            'android/**/*.*',
            // kotlin
            '**/*$Lambda$*.*',
            '**/*$inlined$*.*',
            '**/*$default$*.*',
            '**/androidx/**/*.*',
            '**/com/google/**/*.*',
            '**/uk/xmlangel/googledrivesync/ui/theme/*.*',
        ]

        def debugTree = fileTree(dir: "${buildDir}/intermediates/built_in_kotlinc/debug/compileDebugKotlin/classes", excludes: fileFilter)
        def mainSrc = "${project.projectDir}/src/main/java"

        sourceDirectories.setFrom(files([mainSrc]))
        classDirectories.setFrom(files([debugTree]))
        executionData.setFrom(fileTree(dir: "$buildDir", includes: [
            "jacoco/testDebugUnitTest.exec",
            "outputs/unit_test_code_coverage/debugUnitTest/testDebugUnitTest.exec"
        ]))
    }

    // Ensure it runs after unit tests
    tasks.named('testDebugUnitTest').configure {
        finalizedBy 'patchJUnitXml'
    }
}

// Task to patch JUnit XML with metadata extracted from stdout
tasks.register('patchJUnitXml') {
    doLast {
        def resultsDir = file("${project.buildDir}/test-results/testDebugUnitTest")
        if (!resultsDir.exists()) return

        resultsDir.eachFileMatch(~/TEST-.*\.xml/) { xmlFile ->
            if (xmlFile.length() == 0) return
            def xmlText = xmlFile.getText("UTF-8")
            def xml = new groovy.xml.XmlParser().parseText(xmlText)
            
            def allMetadata = [:] // testName -> [key: value]
            
            xmlText.eachLine { line ->
                def matcher = (line =~ /\[METADATA:(.*?):(.*?)=(.*?)\]/)
                if (matcher.find()) {
                    matcher.each { match ->
                        def testName = match[1].trim()
                        def key = match[2].trim()
                        def value = match[3].trim()
                        if (!allMetadata[testName]) allMetadata[testName] = [:]
                        allMetadata[testName][key] = value
                    }
                }
            }

            def testcases = xml.depthFirst().findAll { it.name() == 'testcase' }
            testcases.each { testcase ->
                def testName = testcase.attribute('name').toString()
                def metadata = allMetadata[testName]
                if (metadata) {
                    testcase.children().findAll { it.name() == 'properties' }.each { 
                        testcase.children().remove(it) 
                    }
                    
                    def props = new Node(null, 'properties')
                    metadata.each { key, value ->
                        new Node(props, 'property', [name: key.toLowerCase(), value: value])
                    }
                    testcase.children().add(0, props)
                }
            }
            
            xmlFile.withPrintWriter("UTF-8") { pw ->
                def printer = new groovy.xml.XmlNodePrinter(pw)
                printer.preserveWhitespace = true
                printer.print(xml)
            }
        }
    }
}

